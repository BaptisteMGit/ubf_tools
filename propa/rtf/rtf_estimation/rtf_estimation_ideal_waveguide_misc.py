#!/usr/bin/env python
# -*-coding:utf-8 -*-
"""
@File    :   rtf_estimation_testcase.py
@Time    :   2024/10/10 17:34:19
@Author  :   Menetrier Baptiste 
@Version :   1.0
@Contact :   baptiste.menetrier@ecole-navale.fr
@Desc    :   Test the RTF estimation feasibility by considering the ideal waveguide model with a single source and noise generated by a set of 
            sources close to the surface. 
"""

# ======================================================================================================================
# Import
# ======================================================================================================================
import numpy as np
import matplotlib.pyplot as plt
import scipy as sp

from misc import *
from scipy.optimize import curve_fit
from propa.rtf.ideal_waveguide import *
from real_data_analysis.real_data_utils import *
from signals.signals import generate_ship_signal
from propa.rtf.rtf_estimation.rtf_estimation_utils import *


def received_signal(duration, fs, z_src, r_src, z_rcv, x_rcv, depth):
    """
    Derive the received signal at the receivers.
    The signal is modeled as a ship signal propagating in the ideal waveguide.
    """

    # Define range
    r_src_rcv = r_src - x_rcv

    # Create source signal
    f0 = 4.5
    std_fi = 1e-2 * f0
    tau_corr_fi = 0.1 * 1 / f0

    s, t = generate_ship_signal(
        Ttot=duration,
        f0=f0,
        std_fi=std_fi,
        tau_corr_fi=tau_corr_fi,
        fs=fs,
        normalize="var",
    )

    src_spectrum = np.fft.rfft(s)

    ns = len(s)
    f = np.fft.rfftfreq(ns, 1 / fs)
    # Remove frequencies below cutoff before calling h_mat to ensure tf and src_spectrum have the same shape along frequency axis
    idx_above_cutoff = f > cutoff_frequency(c0, depth)
    f = f[idx_above_cutoff]
    src_spectrum = src_spectrum[idx_above_cutoff]

    # Derive the transfert function
    _, tf = h_mat(
        f=f,
        z_src=z_src,
        z_rcv=z_rcv,
        r_rcv=r_src_rcv,
        depth=depth,
    )

    # Rq: Shape of the transfer function is (nfreq, nz_rcv, nr_rcv, n_rcv).
    # As only one rcv depth  and one rcv range are considered we can remove second and third dimensions
    tf = np.squeeze(tf, axis=(1, 2))

    # Received signal spectrum resulting from the convolution of the source signal and the impulse response
    transmited_sig_field_f = mult_along_axis(tf, src_spectrum, axis=0)
    rcv_sig = np.fft.irfft(transmited_sig_field_f, axis=0, n=ns)

    # Derive time
    t = np.arange(0, len(rcv_sig)) * 1 / fs

    return t, rcv_sig


def received_noise(duration, fs, z_rcv, x_rcv, depth, max_range, snr_dB=10):
    """
    Derive the received noise field at the receivers.
    The noise field is modeled as a set of sources located on a plane just below the surface following a similar approach as the one used by Kuperman and Ingenito 1992.

    """

    # Range from sources to rcv
    n_src_noise = 1e3  # Number of noise sources
    z_src_noise = 0.5  # Depth of the noise sources (m)
    # Minimum range from the receiver to the set of noises sources (m) -> So that contribution from the intergral over continuous spectrum can be neglected
    minimum_range_from_rcv = 10 * depth
    minimum_range_from_rcv += np.max(x_rcv)
    r_src_noise = np.linspace(
        minimum_range_from_rcv, max_range, int(n_src_noise)
    )  # Range of the noise sources (m)

    # Cast to required shape depending on the number of receivers
    r_src_list_2D = np.tile(r_src_noise, (len(x_rcv), 1)).T
    r_src_rcv = r_src_list_2D - x_rcv

    # Create noise signal
    ns = int(duration * fs)
    sigma_v2 = 10 ** (-snr_dB / 10)
    v = np.random.normal(loc=0, scale=np.sqrt(sigma_v2), size=ns)

    noise_spectrum = np.fft.rfft(v)

    # Derive the transfert function
    f = np.fft.rfftfreq(ns, 1 / fs)
    # Remove frequencies below cutoff before calling h_mat to ensure tf and noise_spectrum have the same shape along frequency axis
    idx_above_cutoff = f > cutoff_frequency(c0, depth)
    f = f[idx_above_cutoff]
    noise_spectrum = noise_spectrum[idx_above_cutoff]

    _, tf = h_mat(
        f=f,
        z_src=z_src_noise,
        z_rcv=z_rcv,
        r_rcv=r_src_rcv,
        depth=depth,
    )

    # Rq: Shape of the transfer function is (nfreq, nz_rcv, nr_rcv, n_rcv). As only one rcv depth is considered we can remove the second dimensions
    tf = np.squeeze(tf, axis=1)

    # Received signal spectrum resulting from the convolution of the source signal and the impulse response
    transmited_noise_field_f = mult_along_axis(tf, noise_spectrum, axis=0)
    rcv_noise_sigs = np.fft.irfft(transmited_noise_field_f, axis=0, n=ns)

    # Sum over all noise sources to get the received noise at each receiver
    rcv_noise = np.sum(rcv_noise_sigs, axis=1)

    # Derive time
    t = np.arange(0, ns) * 1 / fs

    return t, rcv_noise


def testcase_params():
    dur = 20
    fs = 100
    depth = 1000

    n_rcv = 5
    z_rcv = depth - 1
    delta_rcv = 1000
    x_rcv = np.array([i * delta_rcv for i in range(n_rcv)])

    z_src = 5  # Source depth (m)
    r_src = 2.5 * 1e4  # Source range (m)

    return dur, fs, depth, n_rcv, z_rcv, x_rcv, z_src, r_src


def estimate_waveguide_response_delay(z_src, r_src, z_rcv, depth, show_ri=False):
    """
    Estimated the waveguide response duration by calculating the impulse response for the first receiver (reference receiver).
    The waveguide response duration is defined as the time delay between the first and the frist arrival with a significantly low amplitude.
    By analogy with the reverberation time in room acoustics, the waveguide response duration is defined as the time it takes for the sound to decay by 60 dB.
    """
    # Image source
    # Load ir source image
    root = r"C:\Users\baptiste.menetrier\Desktop\devPy\phd\propa\rtf\data"
    fpath = os.path.join(root, "src_image_ir.csv")
    t_img, ir_img = np.loadtxt(fpath, delimiter=",", unpack=True)
    ts = t_img[1] - t_img[0]

    # Detect arrivals (peaks)
    dist = int(0.2 / ts)
    peaks, _ = sp.find_peaks(ir_img, height=0.1 * 1e-8, distance=dist)
    t_peaks = t_img[peaks]
    ir_peaks = ir_img[peaks]
    direct = ir_peaks[0]
    lvl_rel_to_direct = 10 * np.log10(ir_peaks / direct)

    # Fit the echo decreasing curve
    def echo_curve(t, a, b, c):
        return a / (t - b) + c

    # Fit the curve
    popt, pcov = curve_fit(echo_curve, t_peaks, ir_peaks)
    a, b, c = popt
    # Derive the echo lvl according to fitted curve
    t_fit = np.arange(0, 1.2 * np.max(t_peaks), ts)
    ir_img_fitted = echo_curve(t_fit, a, b, c)
    lvl_rel_to_direct_fitted = 10 * np.log10(ir_img_fitted / direct)

    # Find the response duration as the first instant satisfying lvl < -60 dB
    lmin = -60
    gref = direct
    tau_60 = a / (gref * 10 ** (lmin / 10) - c) + b
    print(f"Waveguide response duration : {tau_60} s")

    if show_ri:
        plt.figure()
        plt.plot(t_img, ir_img)
        # plt.plot(t_img, ir_img_filtered, label="low pass filtered")
        plt.scatter(t_peaks, ir_peaks, color="r")
        plt.plot(t_fit, ir_img_fitted, "--", label="Fitted curve")
        plt.ylim([-1.1 * np.max(ir_img), 1.1 * np.max(ir_img)])
        plt.xlim([0, 1.4 * np.max(t_img)])
        plt.xlabel(r"$t \, \textrm{[s]}$")
        plt.ylabel(r"$h(t)$")
        plt.legend()

        plt.figure()
        # plt.plot(t_fit, lvl_rel_to_direct_fitted)
        plt.scatter(t_peaks, lvl_rel_to_direct)
        # plt.scatter(t_peaks, ir_peaks, color="r")
        # plt.plot(t_fit, ir_img_fitted, "--", label="Fitted curve")
        plt.xlabel(r"$t \, \textrm{[s]}$")

    plt.show()


if __name__ == "__main__":
    dur = 20
    fs = 100
    depth = 1000
    max_range = 3 * 1e4

    n_rcv = 5
    z_src = 5
    z_rcv = depth - 1
    delta_rcv = 1000
    x_rcv = np.array([i * delta_rcv for i in range(n_rcv)])

    snr_dB = 100

    # test_rcv_noise()
    # test_rcv_signal()
    # test_all_signals(snr_dB)

    # test_rtf_cs(snr_dB)
    # test_rtf_cw(snr_dB)

    estimate_waveguide_response_delay(
        z_src=z_src, r_src=max_range, z_rcv=z_rcv, depth=depth, show_ri=True
    )
